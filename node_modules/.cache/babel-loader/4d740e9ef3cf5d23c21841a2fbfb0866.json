{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar OutMode_1 = require(\"../../Enums/OutMode\");\n\nvar Utils_1 = require(\"../Utils/Utils\");\n\nvar PolygonMaskType_1 = require(\"../../Enums/PolygonMaskType\");\n\nvar Mover_1 = require(\"./Mover\");\n\nvar RotateDirection_1 = require(\"../../Enums/RotateDirection\");\n\nvar Updater = function () {\n  function Updater(container, particle) {\n    this.container = container;\n    this.particle = particle;\n    this.mover = new Mover_1.Mover(container, particle);\n  }\n\n  Updater.checkBounds = function (coordinate, radius, size, outside) {\n    if (coordinate + radius > size || coordinate - radius < 0) {\n      outside();\n    }\n  };\n\n  Updater.prototype.update = function (delta) {\n    this.mover.move(delta);\n    this.updateOpacity();\n    this.updateSize();\n    this.updateAngle();\n    this.fixOutOfCanvasPosition();\n    this.updateOutMode();\n  };\n\n  Updater.prototype.updateOpacity = function () {\n    var container = this.container;\n    var options = container.options;\n    var particle = this.particle;\n\n    if (options.particles.opacity.animation.enable) {\n      if (particle.opacity.status) {\n        if (particle.opacity.value >= options.particles.opacity.value) {\n          particle.opacity.status = false;\n        }\n\n        particle.opacity.value += particle.opacity.velocity || 0;\n      } else {\n        if (particle.opacity.value <= options.particles.opacity.animation.minimumValue) {\n          particle.opacity.status = true;\n        }\n\n        particle.opacity.value -= particle.opacity.velocity || 0;\n      }\n\n      if (particle.opacity.value < 0) {\n        particle.opacity.value = 0;\n      }\n    }\n  };\n\n  Updater.prototype.updateSize = function () {\n    var container = this.container;\n    var options = container.options;\n    var particle = this.particle;\n\n    if (options.particles.size.animation.enable) {\n      if (particle.size.status) {\n        if (particle.radius >= container.retina.sizeValue) {\n          particle.size.status = false;\n        }\n\n        particle.radius += particle.size.velocity || 0;\n      } else {\n        if (particle.radius <= options.particles.size.animation.minimumValue) {\n          particle.size.status = true;\n        }\n\n        particle.radius -= particle.size.velocity || 0;\n      }\n\n      if (particle.radius < 0) {\n        particle.radius = 0;\n      }\n    }\n  };\n\n  Updater.prototype.updateAngle = function () {\n    var container = this.container;\n    var options = container.options;\n    var particle = this.particle;\n\n    if (options.particles.rotate.animation.enable) {\n      switch (particle.rotateDirection) {\n        case RotateDirection_1.RotateDirection.clockwise:\n          particle.angle += options.particles.rotate.animation.speed * Math.PI / 18;\n\n          if (particle.angle > 360) {\n            particle.angle -= 360;\n          }\n\n          break;\n\n        case RotateDirection_1.RotateDirection.counterClockwise:\n        default:\n          particle.angle -= options.particles.rotate.animation.speed * Math.PI / 18;\n\n          if (particle.angle < 0) {\n            particle.angle += 360;\n          }\n\n          break;\n      }\n    }\n  };\n\n  Updater.prototype.fixOutOfCanvasPosition = function () {\n    var container = this.container;\n    var options = container.options;\n    var particle = this.particle;\n    var outMode = options.particles.move.outMode;\n    var canvasSize = container.canvas.dimension;\n    var newPos;\n\n    if (outMode === OutMode_1.OutMode.bounce) {\n      newPos = {\n        bottom: canvasSize.height,\n        left: particle.radius,\n        right: canvasSize.width,\n        top: particle.radius\n      };\n    } else if (outMode === OutMode_1.OutMode.bounceHorizontal) {\n      newPos = {\n        bottom: canvasSize.height + particle.radius - particle.offset.y,\n        left: particle.radius,\n        right: canvasSize.width,\n        top: -particle.radius - particle.offset.y\n      };\n    } else if (outMode === OutMode_1.OutMode.bounceVertical) {\n      newPos = {\n        bottom: canvasSize.height,\n        left: -particle.radius - particle.offset.x,\n        right: canvasSize.width + particle.radius + particle.offset.x,\n        top: particle.radius\n      };\n    } else {\n      newPos = {\n        bottom: canvasSize.height + particle.radius - particle.offset.y,\n        left: -particle.radius - particle.offset.x,\n        right: canvasSize.width + particle.radius + particle.offset.x,\n        top: -particle.radius - particle.offset.y\n      };\n    }\n\n    if (outMode === OutMode_1.OutMode.destroy) {\n      if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.dimension, particle.radius)) {\n        container.particles.remove(particle);\n      }\n    } else {\n      var nextBounds = Utils_1.Utils.calculateBounds(particle.position, particle.radius);\n\n      if (nextBounds.left > canvasSize.width - particle.offset.x) {\n        particle.position.x = newPos.left;\n        particle.position.y = Math.random() * canvasSize.height;\n      } else if (nextBounds.right < -particle.offset.x) {\n        particle.position.x = newPos.right;\n        particle.position.y = Math.random() * canvasSize.height;\n      }\n\n      if (nextBounds.top > canvasSize.height - particle.offset.y) {\n        particle.position.y = newPos.top;\n        particle.position.x = Math.random() * canvasSize.width;\n      } else if (nextBounds.bottom < -particle.offset.y) {\n        particle.position.y = newPos.bottom;\n        particle.position.x = Math.random() * canvasSize.width;\n      }\n    }\n  };\n\n  Updater.prototype.updateOutMode = function () {\n    var container = this.container;\n    var options = container.options;\n\n    switch (options.particles.move.outMode) {\n      case OutMode_1.OutMode.bounce:\n      case OutMode_1.OutMode.bounceVertical:\n      case OutMode_1.OutMode.bounceHorizontal:\n        this.updateBounce();\n        break;\n    }\n  };\n\n  Updater.prototype.updateBounce = function () {\n    var container = this.container;\n    var options = container.options;\n    var particle = this.particle;\n\n    if (options.polygon.enable && options.polygon.type !== PolygonMaskType_1.PolygonMaskType.none && options.polygon.type !== PolygonMaskType_1.PolygonMaskType.inline) {\n      if (!container.polygon.checkInsidePolygon(particle.position)) {\n        this.polygonBounce();\n      }\n    } else if (options.polygon.enable && options.polygon.type === PolygonMaskType_1.PolygonMaskType.inline) {\n      if (particle.initialPosition) {\n        var dist = Utils_1.Utils.getDistanceBetweenCoordinates(particle.initialPosition, particle.position);\n\n        if (dist > container.retina.polygonMaskMoveRadius) {\n          this.polygonBounce();\n        }\n      }\n    } else {\n      var outMode = options.particles.move.outMode;\n      var x = particle.position.x + particle.offset.x;\n      var y = particle.position.y + particle.offset.y;\n\n      if (outMode === OutMode_1.OutMode.bounce || outMode === OutMode_1.OutMode.bounceHorizontal) {\n        Updater.checkBounds(x, particle.radius, container.canvas.dimension.width, function () {\n          particle.velocity.horizontal = -particle.velocity.horizontal;\n        });\n      }\n\n      if (outMode === OutMode_1.OutMode.bounce || outMode === OutMode_1.OutMode.bounceVertical) {\n        Updater.checkBounds(y, particle.radius, container.canvas.dimension.height, function () {\n          particle.velocity.vertical = -particle.velocity.vertical;\n        });\n      }\n    }\n  };\n\n  Updater.prototype.polygonBounce = function () {\n    var particle = this.particle;\n    particle.velocity.horizontal = -particle.velocity.horizontal + particle.velocity.vertical / 2;\n    particle.velocity.vertical = -particle.velocity.vertical + particle.velocity.horizontal / 2;\n  };\n\n  return Updater;\n}();\n\nexports.Updater = Updater;","map":{"version":3,"sources":["C:/Users/Sheetal/Desktop/facerecognition/node_modules/tsparticles/dist/Classes/Particle/Updater.js"],"names":["Object","defineProperty","exports","value","OutMode_1","require","Utils_1","PolygonMaskType_1","Mover_1","RotateDirection_1","Updater","container","particle","mover","Mover","checkBounds","coordinate","radius","size","outside","prototype","update","delta","move","updateOpacity","updateSize","updateAngle","fixOutOfCanvasPosition","updateOutMode","options","particles","opacity","animation","enable","status","velocity","minimumValue","retina","sizeValue","rotate","rotateDirection","RotateDirection","clockwise","angle","speed","Math","PI","counterClockwise","outMode","canvasSize","canvas","dimension","newPos","OutMode","bounce","bottom","height","left","right","width","top","bounceHorizontal","offset","y","bounceVertical","x","destroy","Utils","isPointInside","position","remove","nextBounds","calculateBounds","random","updateBounce","polygon","type","PolygonMaskType","none","inline","checkInsidePolygon","polygonBounce","initialPosition","dist","getDistanceBetweenCoordinates","polygonMaskMoveRadius","horizontal","vertical"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar OutMode_1 = require(\"../../Enums/OutMode\");\nvar Utils_1 = require(\"../Utils/Utils\");\nvar PolygonMaskType_1 = require(\"../../Enums/PolygonMaskType\");\nvar Mover_1 = require(\"./Mover\");\nvar RotateDirection_1 = require(\"../../Enums/RotateDirection\");\nvar Updater = (function () {\n    function Updater(container, particle) {\n        this.container = container;\n        this.particle = particle;\n        this.mover = new Mover_1.Mover(container, particle);\n    }\n    Updater.checkBounds = function (coordinate, radius, size, outside) {\n        if ((coordinate + radius > size) || (coordinate - radius < 0)) {\n            outside();\n        }\n    };\n    Updater.prototype.update = function (delta) {\n        this.mover.move(delta);\n        this.updateOpacity();\n        this.updateSize();\n        this.updateAngle();\n        this.fixOutOfCanvasPosition();\n        this.updateOutMode();\n    };\n    Updater.prototype.updateOpacity = function () {\n        var container = this.container;\n        var options = container.options;\n        var particle = this.particle;\n        if (options.particles.opacity.animation.enable) {\n            if (particle.opacity.status) {\n                if (particle.opacity.value >= options.particles.opacity.value) {\n                    particle.opacity.status = false;\n                }\n                particle.opacity.value += (particle.opacity.velocity || 0);\n            }\n            else {\n                if (particle.opacity.value <= options.particles.opacity.animation.minimumValue) {\n                    particle.opacity.status = true;\n                }\n                particle.opacity.value -= (particle.opacity.velocity || 0);\n            }\n            if (particle.opacity.value < 0) {\n                particle.opacity.value = 0;\n            }\n        }\n    };\n    Updater.prototype.updateSize = function () {\n        var container = this.container;\n        var options = container.options;\n        var particle = this.particle;\n        if (options.particles.size.animation.enable) {\n            if (particle.size.status) {\n                if (particle.radius >= container.retina.sizeValue) {\n                    particle.size.status = false;\n                }\n                particle.radius += (particle.size.velocity || 0);\n            }\n            else {\n                if (particle.radius <= options.particles.size.animation.minimumValue) {\n                    particle.size.status = true;\n                }\n                particle.radius -= (particle.size.velocity || 0);\n            }\n            if (particle.radius < 0) {\n                particle.radius = 0;\n            }\n        }\n    };\n    Updater.prototype.updateAngle = function () {\n        var container = this.container;\n        var options = container.options;\n        var particle = this.particle;\n        if (options.particles.rotate.animation.enable) {\n            switch (particle.rotateDirection) {\n                case RotateDirection_1.RotateDirection.clockwise:\n                    particle.angle += options.particles.rotate.animation.speed * Math.PI / 18;\n                    if (particle.angle > 360) {\n                        particle.angle -= 360;\n                    }\n                    break;\n                case RotateDirection_1.RotateDirection.counterClockwise:\n                default:\n                    particle.angle -= options.particles.rotate.animation.speed * Math.PI / 18;\n                    if (particle.angle < 0) {\n                        particle.angle += 360;\n                    }\n                    break;\n            }\n        }\n    };\n    Updater.prototype.fixOutOfCanvasPosition = function () {\n        var container = this.container;\n        var options = container.options;\n        var particle = this.particle;\n        var outMode = options.particles.move.outMode;\n        var canvasSize = container.canvas.dimension;\n        var newPos;\n        if (outMode === OutMode_1.OutMode.bounce) {\n            newPos = {\n                bottom: canvasSize.height,\n                left: particle.radius,\n                right: canvasSize.width,\n                top: particle.radius,\n            };\n        }\n        else if (outMode === OutMode_1.OutMode.bounceHorizontal) {\n            newPos = {\n                bottom: canvasSize.height + particle.radius - particle.offset.y,\n                left: particle.radius,\n                right: canvasSize.width,\n                top: -particle.radius - particle.offset.y,\n            };\n        }\n        else if (outMode === OutMode_1.OutMode.bounceVertical) {\n            newPos = {\n                bottom: canvasSize.height,\n                left: -particle.radius - particle.offset.x,\n                right: canvasSize.width + particle.radius + particle.offset.x,\n                top: particle.radius,\n            };\n        }\n        else {\n            newPos = {\n                bottom: canvasSize.height + particle.radius - particle.offset.y,\n                left: -particle.radius - particle.offset.x,\n                right: canvasSize.width + particle.radius + particle.offset.x,\n                top: -particle.radius - particle.offset.y,\n            };\n        }\n        if (outMode === OutMode_1.OutMode.destroy) {\n            if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.dimension, particle.radius)) {\n                container.particles.remove(particle);\n            }\n        }\n        else {\n            var nextBounds = Utils_1.Utils.calculateBounds(particle.position, particle.radius);\n            if (nextBounds.left > canvasSize.width - particle.offset.x) {\n                particle.position.x = newPos.left;\n                particle.position.y = Math.random() * canvasSize.height;\n            }\n            else if (nextBounds.right < -particle.offset.x) {\n                particle.position.x = newPos.right;\n                particle.position.y = Math.random() * canvasSize.height;\n            }\n            if (nextBounds.top > canvasSize.height - particle.offset.y) {\n                particle.position.y = newPos.top;\n                particle.position.x = Math.random() * canvasSize.width;\n            }\n            else if (nextBounds.bottom < -particle.offset.y) {\n                particle.position.y = newPos.bottom;\n                particle.position.x = Math.random() * canvasSize.width;\n            }\n        }\n    };\n    Updater.prototype.updateOutMode = function () {\n        var container = this.container;\n        var options = container.options;\n        switch (options.particles.move.outMode) {\n            case OutMode_1.OutMode.bounce:\n            case OutMode_1.OutMode.bounceVertical:\n            case OutMode_1.OutMode.bounceHorizontal:\n                this.updateBounce();\n                break;\n        }\n    };\n    Updater.prototype.updateBounce = function () {\n        var container = this.container;\n        var options = container.options;\n        var particle = this.particle;\n        if (options.polygon.enable && options.polygon.type !== PolygonMaskType_1.PolygonMaskType.none &&\n            options.polygon.type !== PolygonMaskType_1.PolygonMaskType.inline) {\n            if (!container.polygon.checkInsidePolygon(particle.position)) {\n                this.polygonBounce();\n            }\n        }\n        else if (options.polygon.enable && options.polygon.type === PolygonMaskType_1.PolygonMaskType.inline) {\n            if (particle.initialPosition) {\n                var dist = Utils_1.Utils.getDistanceBetweenCoordinates(particle.initialPosition, particle.position);\n                if (dist > container.retina.polygonMaskMoveRadius) {\n                    this.polygonBounce();\n                }\n            }\n        }\n        else {\n            var outMode = options.particles.move.outMode;\n            var x = particle.position.x + particle.offset.x;\n            var y = particle.position.y + particle.offset.y;\n            if (outMode === OutMode_1.OutMode.bounce || outMode === OutMode_1.OutMode.bounceHorizontal) {\n                Updater.checkBounds(x, particle.radius, container.canvas.dimension.width, function () {\n                    particle.velocity.horizontal = -particle.velocity.horizontal;\n                });\n            }\n            if (outMode === OutMode_1.OutMode.bounce || outMode === OutMode_1.OutMode.bounceVertical) {\n                Updater.checkBounds(y, particle.radius, container.canvas.dimension.height, function () {\n                    particle.velocity.vertical = -particle.velocity.vertical;\n                });\n            }\n        }\n    };\n    Updater.prototype.polygonBounce = function () {\n        var particle = this.particle;\n        particle.velocity.horizontal = -particle.velocity.horizontal + (particle.velocity.vertical / 2);\n        particle.velocity.vertical = -particle.velocity.vertical + (particle.velocity.horizontal / 2);\n    };\n    return Updater;\n}());\nexports.Updater = Updater;\n"]},"metadata":{},"sourceType":"script"}